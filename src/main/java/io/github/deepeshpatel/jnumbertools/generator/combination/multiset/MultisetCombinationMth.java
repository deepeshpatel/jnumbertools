/*
 * JNumberTools Library v3.0.1
 * Copyright (c) 2025 Deepesh Patel (patel.deepesh@gmail.com)
 */
package io.github.deepeshpatel.jnumbertools.generator.combination.multiset;

import io.github.deepeshpatel.jnumbertools.base.Calculator;
import io.github.deepeshpatel.jnumbertools.generator.base.AbstractGenerator;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Generates every mᵗʰ multiset combination in lexicographic order, starting at a specified rank.
 * <p>
 * The multiset is defined by a list of distinct elements (in lex order) and an array of corresponding frequencies.
 * A combination is defined as a multiset selection of exactly r items (where r must be ≤ the total number of items).
 * Each combination is generated by unranking a count vector (which specifies how many of each element are selected)
 * and then converting that vector into the actual combination (a list of items, with repetitions).
 * </p>
 * <p>
 * The constructor takes a start rank and an increment (step). For example, if <code>start = 3</code> and <code>m = 2</code>,
 * then the iterator returns the 3rd, 5th, 7th, … combination (in lexicographic order). If <code>start = 0</code> and <code>m = 0</code>,
 * then m is interpreted as a default step of 5.
 * </p>
 *
 * @param <T> the type of elements in the combinations
 */
public final class MultisetCombinationMth<T> extends AbstractGenerator<T> implements Iterable<List<T>> {

    private final int[] frequencies;
    private final int r;
    private final long start;
    private long increment;
    private final int total;

    /**
     * Constructs a MultisetCombinationMth generator.
     *
     * @param elements    a list of distinct items (in lexicographic order)
     * @param r           the number of items to select in each combination
     * @param start       the 0-indexed rank of the first combination to generate
     * @param increment   positive step size (every mᵗʰ combination is returned);
     * @param frequencies an array of nonnegative integers representing the available count for each item;
     *                    its length must equal the size of {@code elements}
     * @throws IllegalArgumentException if r or start is negative, if increment is negative,
     *                                  or if the length of frequencies does not match the number of elements.
     */
    public MultisetCombinationMth(List<T> elements, int r, long start, long increment, int[] frequencies) {
        super(elements);

        if (r < 0 || start < 0 || increment <= 0 || elements.size() != frequencies.length) {
            String msg = "Must follow constraint(s):  r >=0 and start >=0 and " +
                    "increment >0 and Elements.size() == frequencies.length ";
            throw new IllegalArgumentException(msg);
        }

        int totalAvailable = Arrays.stream(frequencies).sum();
        this.r = r > totalAvailable ? 0 : r;
        this.frequencies = frequencies;
        this.start = start;
        this.increment = (increment == 0) ? 5 : increment;
        this.total = Calculator.multisetCombinationsCount(r, frequencies);
    }

    @Override
    public Iterator<List<T>> iterator() {
        // If no combinations can be generated, return an empty iterator.
        return (r == 0 || elements.isEmpty()) ? newEmptyIterator() : new Itr();
    }

    private class Itr implements Iterator<List<T>> {
        private long currentRank;

        private Itr() {
            currentRank = start;
        }

        @Override
        public boolean hasNext() {
            return currentRank < total;
        }

        @Override
        public List<T> next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            // Unrank the combination corresponding to currentRank.
            int[] countVector = unrankMultisetCombination(r, frequencies, (int) currentRank);
            List<T> combination = new ArrayList<>();
            // Convert count vector to the actual combination.
            for (int i = 0; i < countVector.length; i++) {
                for (int j = 0; j < countVector[i]; j++) {
                    combination.add(elements.get(i));
                }
            }
            currentRank += increment;
            return combination;
        }
    }

    /**
     * Unranks the multiset combination corresponding to the given rank (0-indexed), returning a count vector.
     * <p>
     * The count vector is an array of integers of the same length as {@code frequencies} whose sum is k,
     * where each element indicates how many items of that type are selected. This version iterates in descending
     * order for each item type so that the resulting multiset combination (after converting the count vector) is in
     * lexicographic order (smallest first).
     * </p>
     *
     * @param k           the total number of items to select
     * @param frequencies an array of nonnegative integers representing the available count for each item type
     * @param rank        the 0-indexed rank of the desired combination (in lex order of the resulting multisets)
     * @return an int array representing the count vector (its entries sum to k)
     */
    public  int[] unrankMultisetCombination(int k, int[] frequencies, int rank) {
        int n = frequencies.length;
        int[] combination = new int[n];
        TwoLevelMap<Integer, Integer, Integer> memo = new TwoLevelMap<>();
        for (int i = 0; i < n; i++) {
            int maxForThisType = Math.min(frequencies[i], k);
            for (int x = maxForThisType; x >= 0; x--) {
                int ways = Calculator.multisetCombinationsCountStartingFromIndex(k-x, i+1, frequencies);
                if (rank < ways) {
                    combination[i] = x;
                    k -= x;
                    break;
                } else {
                    rank -= ways;
                }
            }
        }
        return combination;
    }

    /**
     * A simple two-level map for memoization.
     *
     * @param <K1> the type of the first key
     * @param <K2> the type of the second key
     * @param <V>  the type of the value
     */
    public static class TwoLevelMap<K1, K2, V> extends ConcurrentHashMap<K1, Map<K2, V>> {
        public V get(K1 key1, K2 key2) {
            Map<K2, V> inner = get(key1);
            return inner == null ? null : inner.get(key2);
        }
        public V put(K1 key1, K2 key2, V value) {
            computeIfAbsent(key1, k -> new ConcurrentHashMap<>()).put(key2, value);
            return value;
        }
    }
}
